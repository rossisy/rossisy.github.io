---
layout: post
title: "程序管理"
date: 2019-02-09 10:00:00 +0800
categories: Linux 
---

# process
在Linux系统当中，触发任何一个事件，系统都会将它定义成为一个进程，并且给予这个进程一个ID，称为PID，同时依据触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设置。

## process & program
program：
通常为二进制程序，放置在存储媒介中（如硬盘、光盘、软盘、磁带等），以物理文件的形式存在
process：
程序被触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载到内存中，操作系统并给予这个内存内的单元一个标识符（PID），可以说，进程就是一个正在运行中的程序
子进程与父进程：
当登录系统后，会取得一个bash的shell，再用这个bash提供的接口去执行另一个命令，也会被触发成为PID，这个后来触发产生的PID就是“子进程”，而在原本的bash环境下的shell就称为“父进程”
fork and exec(过程调用的流程)：
在Linux的过程调用中通常称为fork-and-exec的流程。进程都会通过父进程以复制（fork）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以exec的方式来执行实际要进行的进程，最终就成为一个子进程的存在。
系统或网络服务：
常驻在内存中的进程。这些进程通常都是负责一些系统所提供的功能以服务用户各项任务，因此这些常驻进程就会被我们称为服务（daemon）。常驻内存的进程大致分为系统本身所需要的服务与负责网络联机的服务，网络服务会启动一个可以负责网络监听的端口以提供外部客户端的连接请求。

## 多用户、多任务环境
多用户环境
因为每个人登录后取得的shell的PID不同，所以每个人进入Linux的环境都可以根据每个人的喜好来设置。
多任务行为
Linux可以让CPU在各个工作间进行切换，即每个工作都仅占去CPU的几个命令次数，所以CPU每秒就能够在各个进程之间进行切换。CPU切换进程的工作与这些工作进入到CPU运行的调度会影响到系统的整体性能。
多重登录环境的七个基本终端窗口
Linux默认提供了6个命令行界面登录窗口，以及一个图形界面。
特殊的进程管理行为
Linux下每个进程之间可能是独立的，也可能有相依性，只要到独立的进程当中，删除有问题的那个进程，它就可以被系统删除掉的
bash环境下的工作管理（job control）
使用符号&将命令放置与后台执行，即在执行命令后，这个终端仍然可以做其他的工作，而在命令执行完毕后，系统会在这个终端显示完成的消息。

# 工作管理（job control）
这个工作管理使用在bash环境下的，也就是说：当我们登录系统取得bash shell之后，在单一终端机下同时进行多个工作的行为管理。

## 什么是工作管理
在进行工作管理的行为中，其实每个工作都是目前bash的子进程，即彼此之间是有相关性的。我们无法以job control的方式由tty1的环境去管理tty2的bash。
要进行bash的job control必须要注意到的限制是：
1. 这些工作所触发的进程必须来自于你shell的子进程（只管理自己的bash）
2. 前台：你可以控制与执行命令的这个环境称为前台的工作
3. 后台：可以自行运行的工作，你无法使用[crtl]+c终止它，可使用bg/fg调用该工作
4. 后台中“执行”的进程不能等待terminal/shell的输入

## job control的管理

### 直接将命令丢到后台中“执行”的&
在执行的命令最后加上&，工作会被放到后台执行，并返回工作号码（job number）与该工作对应的PID。
如果没有使用数据流重定向，则该命令的数据流都会输出到其前台。当前台出现这些数据：
[1]+    Done    命令
就代表[1]这个工作已经完成（Done）。
使用数据流重定向将后台命令输出的信息都传送至某个文件中，可以保持前台环境的数据干净整洁。

### 将目前的工作丢到后台中“暂停”的[ctrl]+z
当前正在执行的工作还未完成时，使用[ctrl]+z将工作丢到后台并暂停，这时会返回工作号码、工作状态与该命令，如：
[1]+    Stopped    vim ~/.bashrc

### 查看目前的后台工作状态：jobs
语法：
jobs [-lrs]
参数：
-l：除了列出job number与命令串之外，同时列出PID的号码
-r：仅列出正在后台run的工作
-s：仅列出正在后台当中暂停的工作

### 将后台工作拿到前台来处理：fg
fg（foreground）就是将后台工作拿到前台来处理的。
语法：
fg %jobnumber
参数：
%jobnumber：jobnumber为工作号码（数字）。注意，那个%是可有可无的

### 让工作在后台下的状态变成运行中：bg
语法：
bg %jobnumber
参数：
%jobnumber：jobnumber为工作号码（数字）。注意，那个%是可有可无的

### 管理后台当中的工作：kill
语法：
kill -signal %jobnumber
kill -l
参数：
-l：这个是L的小写，列出目前kill能够使用的信号（signal）有哪些
signal：代表给予后面接的那个工作什么样的指示。用man 7 signal可知：
    -1：重新读取一次参数的配置文件（类似reload）
	-2：代表与由键盘输入[ctrl]+c同样的操作
	-9：立刻强制删除一个工作
	-15：以正常的程序方式终止一项工作。与-9是不一样的。
kill后面接的数字默认会是PID，如果想要管理bash的工作控制，就得要加上%数字了。

## 脱机管理
在工作管理中提到的“后台”指的是在终端机模式下可以避免[ctrl]+c中断的一个情境，并不是放到系统的后台去。如果工作需要进行一大段时间，又无法放置在后台下面，可以使用at来处理，因为at是将工作放置到系统后台，而与终端机无关。也可以使用nohup这个命令来处理，nohup可以让你在脱机或注销系统后，还能够让工作继续进行。
语法：
nohup [命令与参数] 
nohup [命令与参数] &
需要注意的是，nohup并不支持bash内置的命令，因此命令必须是外部命令才行。

# process mangement

## 进程的查看
利用静态的ps或者是动态的top，还能以pstree来查阅程序树之间的关系

### ps
将某个时间点的进程运行情况选取下来
ps aux：查看系统所有的进程数据
ps -lA：查看所有系统的数据
ps axjf：连同部分进程树
参数：
-A：所有的进程均显示出来，与-e具有同样的作用
-a：不与terminal有关的所有进程
-u：有效用户（effective user）相关的进程
x：通常与a这个参数一起使用，可列出较完整信息
输出格式规划：
    l：较长、较详细地将该PID的信息列出
	j：工作的格式（jobs format）
	-f：做一个更为完整的输出

#### 仅查看自己的bash相关进程：ps -l
系统整体的进程运行是非常多的，但如果使用ps -l则仅列出与你的操作环境（bash）有关的进程而已，即最上层的父进程会是你自己的bash而没有扩展到init这个进程去，ps -l显示出来的数据有：
F：代表这个进程标志（process flags），说明这个进程的权限，常见号码有：
    若为4，表示此进程的权限为root
	若为1，表示此子进程仅可进行复制（fork）而无法实际执行（exec）
S：代表这个进程的状态（STAT），主要的状态有：
    R（Running）：该进程正在运行中
	S（Sleep）：该进程目前正在睡眠状态（idle），但可以被唤醒（signal）
	D：不可被唤醒的睡眠状态，通常这个进程可能在等待I/O的情况（ex>打印）
	T：停止状态（stop），可能是在工作控制（后台暂停）或除错
	Z（Zombie）：“僵尸”状态，进程已经终止但却无法被删除至内存外
UID/PID/PPID：代表此进程被该UID所拥有/进程的PID号码/此进程的父进程PID号码
C：代表CPU使用率，单位为百分比
PRI/NI：Priority/Nice的缩写，代表此进程被CPU所执行的优先级，数值越小代表该进程越快被CPU执行。
ADDR/SZ/WCHAN：都与内存有关，ADDR是kernel function，指出该进程在内存的哪个部分，如果是个running的进程，一般就会显示“-”。SZ代表此进程用掉多少内存/WCHAN表示目前进程是否运行中，同样，若为-表示正在运行中
TTY：登陆者的终端机位置，若为远程登录则使用动态终端接口（pts/n）
TIME：使用掉的CPU时间，注意，是此进程实际花费CPU运行的时间，而不是系统时间
CMD：就是command的缩写，造成此程序的触发进程的命令为何

#### 查看系统所有进程：ps aux
在ps aux显示的项目中，各字段的意义为：
USER：该进程属于哪个用户账号的
PID：该进程的进程标识符
%CPU：该进程使用掉的CPU资源百分比
%MEM：该进程所占用的物理内存百分比
VSZ：该进程使用掉的虚拟内存量（KB）
RSS：该进程占用的固定的内存量（KB）
TTY：该进程是在哪个终端机上面运行，若与终端机无关则显示？另外，tty1~tty6是本机上面的登录者程序，若为pts/0等的，则表示为由网络连接进主机的进程
STAT：该进程目前的状态，状态显示与ps -l的S标识相同（R/S/T/Z）
START：该进程被触发启动的时间
TIME：该进程实际使用CPU运行的时间
COMMAND：该进程的实际命令
一般来说，ps aux会依照PID的顺序来排序显示。

僵尸进程：该进程已经执行完毕，或是因故应该要终止了，但是该进程的父进程却无法完整将该进程结束掉，而造成那个进程一致存在内存当中。如果某个进程的CMD后面还接上<defunct>时，就代表该进程是僵尸进程

### top
动态查看进程的变化。相对于ps是选取一个时间点的进程状态，top则可以持续检测进程运行的状态
语法：
top [-d 数字] | top [-bnp]
参数：
-d：后面可以接秒数，就是整个进程界面更新的秒数。默认是5秒
-b：以批次的方式执行top，还有更多的参数可以使用。通常会搭配数据流重定向来批处理的结果输出称为文件
-n：与-b搭配，意义是，需要进行几次top的输出结果
-p：指定某些个PID来进行查看监测而已
在top执行过程当中可以使用的按键命令：
    ?：显示在top当中可以输入的按键命令
	P：以CPU的使用资源排序显示
	M：以内存的使用资源排序显示
	N：以PID来排序
	T：由该进程使用的CPU时间累积（TIME+）排序
	k：给予某个PID一个信号（signal）
	r：给予某个PID重新制定一个nice值
	q：离开top软件的按键
top主要分为两个界面，上面的界面为整个系统的资源使用状态，基本上总共有六行，显示的内容依序是：
第一行（top...）：这一行显示的信息分别为：目前的时间、开机到目前为止所经过的时间、已经登录系统的用户人数、系统在1，5，15分钟的平均工作负载。
第二行（Tasks...）：显示的是目前进程的总量与个别进程在什么状态（running，sleeping，stopped，zombie）。比较需要注意的是最后的zombie那个数值，如果不是0，好好看看到底是哪个process变成僵尸
第三行（Cpus...）：显示的是CPU的整体负载，每个选项可使用？查阅。需要特别注意的是%wa，那个选项代表的是I/O wait，通常你的系统会变慢都是I/O产生的问题比较大。如果是多内核的设备，可以按下数字键“1”来切换成不同CPU的负载率
第四行与第五行：表示目前的物理内存与虚拟内存（Mem/Swap）的使用情况。要注意的是swap的使用量要尽量少，如果swap被大量使用，表示系统的物理内存实在不足
第六行：这个是当在top进程当中输入命令时显示状态的地方
至于top下半部分的界面，则是每个进程使用的资源情况。比较需要注意的是：
    PID：每个进程的ID
	USER：该进程所属的用户
	PR：Priority的简写，进程的优先执行顺序，越小越早被执行
	NI：Nice的简写，与Priority有关，也是越小越早被执行
	%CPU：CPU的使用率
	%MEM：内存的使用率
	TIME+：CPU使用时间的累加
top默认使用CPU使用率（%CPU）作为排序的重点，如果你想要使用内存使用率排序，则可以按下“M”，若要恢复则按下“P”即可。

### pstree
语法：
pstree [-A|U] [-up]
参数：
-A：各进程树之间的连接以ASCII字符来连接
-U：各进程树之间的连接以utf8码的字符来连接，在某些终端接口下可能会有错误
-p：同时列出每个进程的PID
-u：同时列出每个进程的所属账号名称

## 进程的管理
进程之间是可以互相控制的。程序是通过给予该进程一个信号（signal）去告知该进程你想要让它做什么来进行管理。
主要的信号代号与名称对应及内容：
|代号|名称|内容|
|:-:|:-:|:-|
|1|SIAGHUP|启动被终止的进程，可让该PID重新读取自己的配置文件，类似重新启动|
|2|SIGINT|相当于用键盘输入[ctrl]+c来中断一个进程的进行|
|9|SIGKILL|代表强制中断一个进程的进行，如果该进程进行到一半，那么尚未完成的部分可能会有“半产品”产生，类似vim会有.filename.swp保留下来|
|15|SIGTERM|以正常的结束进程来终止该进程。由于是正常的终止，所以后续的操作会将它完成。不过，如果该进程已经发生问题，就是无法正常的方法终止时，输入这个signal也是没有用的|
|17|SIGSTOP|相当于用键盘输入[ctrl]+z来暂停一个进程的进行|

### kill & killall
使用kill或killall传递信号给某个进程
语法：
kill -signal PID 
kill可以帮我们将这个signal传递给某个工作（%jobnumber）或者是某个PID（直接输入数字）。

语法：
killall -signal 命令名称
killall [-iIe] [command name]
参数：
-i：interactive的意思，交互式的，若需要删除时，会出现提示符给用户
-e：exact的意思，表示后面接的command name要一致，但整个完整的命令不能超过15个字符
-I：命令名称（可能含参数）忽略大小写

### 进程的执行顺序
进程的执行顺序要考虑到程序的优先执行序（Priority）与CPU调度。CPU调度指的是每个程序被CPU运行的演算规则，与操作系统具有相关性

#### Priority与Nice值
CPU一秒钟可以运行多达数G的微命令次数，通过内核的CPU调度可以让各进程被CPU切换运行，因此每个进程在一秒钟内或多或少都会被CPU执行部分的脚本。
Linux给予进程一个所谓的“优先执行序”（Priority，PRI），这个PRI值越低代表越优先的意思。PRI是内核动态调整的，用户无法直接调整，如果想要调整进程的优先执行序，就要通过Nice值。一般来说，PRI与NI的相关性如下：
PRI（new）= PRI（old） + nice
不过要特别留意到的是，如果原本的PRI是50，并不是我们给予一个nice=5，就会让PRI变成55。因为PRI是系统“动态”决定的，所以，虽然nice值是可有影响PRI，不过，最终的PRI仍是要经过系统分析后才会决定的。另外，nice值是有正负的，当nice值为负值时，该程序就会降低PRI值。
nice值可调整的范围为-20~19
root可随意调整自己或他人进程的Nice值
一般用户仅可将nice值越调越高

#### 给予某个进程nice值
方式一：
一开始执行程序就立即给予一个特定的nice值：使用nice命令
语法：
nice [-n 数字] command
参数：
-n：后面接一个数值，数值的范围为-20~19

方式二：
调整某个已经存在的PID的nice值：用renice命令
语法：
renice [number] PID
参数：
PID：某个进程的ID

### 系统资源查看

#### free
查看内存使用情况
语法：
free [-b|-k|-m|-g] [-t]
参数：
-b：直接输入free时，显示的单位是KB。我们可以使用b（bytes）、m（MB）、k（KB）及g（GB）来显示单位。
-t：在输出的最终结果中显示物理内存与swap的总量

#### uname
查看系统与内核相关信息
语法：
uname [-asrmpi]
参数：
-a：所有系统相关的信息，包括下面的数据都会被列出来
-s：系统内核名称
-r：内核的版本
-m：本系统的硬件名称
-p：CPU的类型，与-m类似，只是显示的是CPU的类型
-i：硬件的平台

#### uptime
查看系统启动时间与工作负载

#### netstat
跟踪网络。netstat的输出分为两大部分，分别是网络与系统自己的进程相关性部分。
语法：
netstat -[atunlp]
参数：
-a：将目前系统上所有的连接、监听、Socket数据都列出来
-t：列出tcp网络数据包的数据
-u：列出udp网络数据包的数据
-n：不列出进程的服务名称，以端口号（port number）来显示
-l：列出目前正在网络监听（listen）的服务
-p：列出该网络服务的进程PID

在网络连接情况的部分：
Proto：网络的数据包协议，主要分为TCP与UDP数据包
Recv-Q：非由用户进程连接到此socket的复制的总字节数
Send-Q：非由远程主机传送过来的acknowledge总字节数
LocalAddress：本地的IP端口情况
ForeignAddress：远程主机的IP端口情况
State：连接状态，主要有建立（ESTABLISED)及监听（LISTEN)

在socket的部分：
Proto：一般就是unix
RefCnt：连接到此socket的进程数量
Flags：连接的标识
Type：socket访问的类型。主要有确认连接的STREAM与不需确认的DGRAM两种
State：若为connected表示多个进程之间已经连接建立
Path：连接到此socket的相关程序的路径，或者是相关数据输出的路径

#### dmesg
分析内核产生的信息
所有内核检测的信息，不管是开机的时候还是系统运行过程中，反正只要是内核产生的信息都会被记录到内存中的某个保护区段，dmesg这个命令就能够将该区段的信息读出来。

#### vmstat
检测系统资源变化
语法：
vmstat [-a] [延迟[总计检测次数]] //CPU/内存等信息
vmstat [-fs] //内存相关
vmstat [-S单位]    //设置显示数据的单位
vmstat [-d]    //与磁盘有关
vmstat [-p分区]    //与磁盘有关
参数：
-a：使用inactive/active（活跃与否）替代buffer/cache的内存输出信息
-f：开机到目前为止系统复制（fork）的进程数
-s：将一些事件（开机至目前为止）导致的内存变化情况列表说明
-S：后面可以接单位，让显示的数据有单位。例如K/M取代bytes的容量
-d：列出磁盘的读写总量统计表
-p：后面列出分区，可显示该分区的读写总量统计表

```
[root@rossi ~]# vmstat 1 3
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 3679112   2108 243280    0    0     5     3   13   15  0  0 100  0  0
 0  0      0 3679112   2108 243312    0    0     0     0   11   14  0  0 100  0  0
 0  0      0 3679112   2108 243312    0    0     0     0   19   20  0  0 100  0  0
 ```
 基本说明如下：
 r：等待运行中的进程数量
 b：不可被唤醒的进程数量
 这两个选项越多，代表系统越忙碌。

 swpd：虚拟内存被使用的容量
 free：未被使用的内存容量
 buff：用于缓冲存储器
 cache：用于高速缓存

 si：由磁盘中将程序取出的量
 so：由于内存不足而将没用到的程序写入到磁盘的swap的容量
如果si/so的数值太大，表示内存内的数据经常得在磁盘与内存之间传来传去，系统性能会很差

bi：由磁盘写入的块数量
bo：写入到磁盘去的块数量
这部分的值越高，代表系统的I/O非常忙碌

in：每秒被中断的进程次数
cs：每秒钟进行的事件切换次数
这两个数字越大，代表系统与接口设备的通信非常频繁。

us：非内核层的CPU使用状态
sy：内核层所使用的CPU状态
id：闲置的状态
wa：等待I/O所耗费的CPU状态
st：被虚拟机（virtual machine）所盗用的CPU使用状态

## 特殊文件与程序

### 具有SUID/SGID权限的命令执行状态
SUID的权限与程序的相关性非常大：
    SUID权限仅对二进制程序（binary program）有效
    执行者对于该程序需要具有x的可执行权限
    本权限仅在执行该程序的过程中有效（run-time）
	执行者将具有该程序所有者（owner）的权限

### /proc/*代表的意义
进程都是在内存当中的，而内存当中的数据又都是写入/proc/*这个目录下的，所以，我们可以直接查看/proc这个目录当中的文件。
针对整个Linux系统相关的文件与对应的内容如下：
|文件名|文件内容|
|:-:|:-|
|/proc/cmdline|加载kernel时所执行的相关参数！查阅此文件，可了解系统是如何启动的|
|/proc/cpuinfo|本机的CPU的相关信息，包含频率、类型与运算功能等|
|/proc/devices|这个文件记录了系统各个主要设备的主要设备代号，与mknod有关|
|/proc/filesystems|目前系统已经加载的文件系统|
|/proc/interrupts|目前系统上面的IRQ分配状态|
|/proc/ioports|目前系统上面各个设备所配置的I/O地址|
|/proc/kcore|这个就是内存的大小|
|/proc/loadavg|top以及uptime上头的三个平均数值就是记录在此|
|/proc/meminfo|使用free列出的内存信息|
|/proc/modules|目前Linux已经加载的模块列表，也可以想成是驱动程序|
|/proc/mounts|系统已经挂载的数据，就是用mount这个命令调出来的数据|
|/proc/swaps|系统使用的分区记录在此|
|/proc/partitions|使用fdisk -l会出现目前所有的分区，都在这个文件当中有记录|
|/proc/pci|在PCI总线上面每个设备的详细情况，可用lspci来查阅|
|/proc/uptime|就是用uptime的时候会出现的信息|
|/proc/version|内核的版本，就是用uname -a显示的内容|
|/proc/bus/*|一些总线的设备，还有USB的设备也记录在此|

### 查询已打开文件或已执行程序打开的文件

#### fuser
通过文件（或文件系统）找出正在使用该文件的程序
语法：
fuser [-umv] [-k [i] [-signal]] file/dir
参数：
-u：除了进程的PID之外，同时列出该进程的所有者
-m：后面接的那个文件名会主动上提到该文件系统的顶层，对umount不成功很有效
-v：可以列出每个文件与程序还有命令的完整相关性
-k：找出使用该文件/目录的PID，并试图以SIGKILL这个信号给予该PID
-i：必须与-k配合，在删除PID之前会先询问用户意愿
-signal：例如-1 -15等，默认是SIGKILL（-9）
命令输出的字段中，ACCESS代表的意义为：
	c：此进程在当前的目录下（非子目录）
	e：可被触发为执行状态
	f：是一个被打开的文件
	r：代表顶层目录（root directory）
	F：该文件被打开了，不过在等待回应中
	m：可能为分享的动态函数库

#### lsof
列出被进程所打开的文件名
语法：
lsof [-aUu] [+d]
参数：
-a：多项数据需要“同时成立”才显示出结果
-U：仅列出Unix like系统的socket文件类型
-u：后面接username，列出该用户相关进程所打开的文件
+d：后面接目录，即找出某个目录下面已经被打开的文件

#### pidof
找出某个正在执行的进程的PID
语法：
pidof [-sx] program_name
参数：
-s：仅列出一个PID而不列出所有的PID
-x：同时列出该program name可能的PPID那个进程的PID

## SELinux
SELinux即“Security Enhanced Linux”的缩写，字面意思是安全强化的Linux，当初设计的目标是避免资源的误用
SELinux是在进行程序、文件等权限设置依据的一个内核模块。

传统的文件权限与账号关系：自主访问控制，DAC
系统的账号主要分为系统管理员（root）与一般用户，而这两种身份能否使用系统上面的文件资源则与rwx的权限设置有关。但是，各种权限设置对root是无效的。当某个进程想要对文件进行访问时，系统就会根据该进程的所有者/用户组，并比较文件的权限，若通过权限检查，就可以访问该文件了。
DAC的访问控制有以下几个问题：
1. root具有最高的权限：如果不小心某个程序被有心人取得，且该进程属于root的权限，那么这个程序就可以在系统上进行任何资源的访问
2. 用户可以取得进程来更改文件资源的访问权限：如果你不小心将某个目录的权限设置为777，由于对任何人的权限会变成rwx，因此该目录就会被任何人所任意访问

以策略规则制定特定程序读取特定文件：委托访问控制，MAC
为了避免DAC容易发生的问题，因此SELinux导入了强制访问控制（MandatoryAccessControl，MAC）的方法。
强制访问控制（MAC）可以针对特定的进程与特定的文件资源来进行权限的控制。即使是root，那么在使用不同的进程时，所能取得的权限并不一定是root，而要看当时该进程的设置而定。此外，进程也不能任意使用系统文件资源，因为每个文件资源也针对该进程设置可取用的权限。SELinux提供了一些默认的策略（Policy），并在该策略内提供多个规则（rule），让你可以选择是否启用该控制规则。

### SELinux的运行模式
主体（Subject）
SELinux主要想管理的就是进程，因此主体就是进程
目标（Object）
主体进程能否访问的“目标资源”一般就是文件系统，因此目标就是文件系统
策略（Policy）
由于进程与文件数量庞大，因此SELinux会依据某些服务来指定基本的访问安全性策略。这些策略内还会有详细的规则（rule）来指定不同的服务开发某些资源的访问与否。CentOS 5.x里仅有两个主要的策略，分别是：
    targeted：针对网络服务限制较多，针对本机限制较少，是默认的策略
	strict：完整的SELinux限制，限制方面较为严格
安全上下文（security context）
主体能不能访问目标除了策略指定之外，主体与目标的安全上下文必须一致才能够顺利访问

主体程序要先通过SELinux策略内的规则放行后，才可以与目标资源进行安全上下文的比较，若失败则无法访问目标，若成功则可以开始访问目标。问题是最终的访问成功与否，还是与文件系统的rwx权限设置有关。

安全上下文存在于主体进程中与目标文件资源中。进程在内存中，所以安全上下文可以存入，文件的安全上下文则是放置在文件的inode内的，因此主体进程想要读取目标文件资源时，同样需要读取inode，这inode内就可以比较安全上下文以及rwx等权限值是否正确，而给予适当的读取权限依据

查看安全上下文可以使用“ls -Z”去查看。安全上下文用冒号分为三个字段：
    Identify:role:type
    身份识别:角色:类型
身份识别：
相当于账号方面的身份标识，主要的身份标识则有下面三种常见的类型：
    root：表示root的账号身份；system_u：表示系统程序方面的标识，通常就是进程；user_u：代表的是一般用户账号相关的身份
角色（Role）
通过角色字段，我们可以知道这个数据是属于程序、文件资源还是代表用户，一般的角色有：
    object_r：代表的是文件或目录等文件资源，应该是最常见的；system_r：代表的是进程，不要一般用户也会被指定成为system_r
类型（Type，最重要）
在默认的targeted策略中，Identify与Role字段基本上是不重要的，重要的在于这个类型字段。基本上，一个主体进程能不能读取到这个文件资源与类型字段有关，而类型字段在文件与进程的定义不太相同，分别是：
    type：在文件资源（Object）上面称为类型（Type）；domain：在主体程序（Subject）中则称为域（domain）
	domain需要与type搭配，则该程序才能够顺利读取文件资源

进程与文件及SELinux type字段的相关性
通过身份标识与角色字段的定义，可以约略知道某个进程代表的意义。在targeted策略下的对应如下表所示
|身份识别|角色|在targeted下的意义|
|:-:|:-:|:-|
|root|system_r|代表供root账号所取得的权限|
|system_u|system_r|非交互式的系统运行程序|
|user_u|system_r|一般用户的进程|

主体与目标之间是否具有可以读写的权限与进程的domain及文件的type有关。检验的流程如下：
1. 首先，触发一个可以执行的目标文件
2. 该文件的类型会让这个文件所造成的主体进程（Subject）具有一个域，我们的策略针对这个域已经制定了许多的规则，其中包括这个域可以读取的目标资源类型
3. 由于进程的域被设置为可以读取某个类型的目标文件，因此只要目标文件的类型符合，则就可以被进程所读取
4. 最终能否读取正确的数据，还要看rwx是否符合Linux权限的规范

### SELinux的启动、关闭与查看
目前SELinux支持三种模式，分别如下：
    enforcing：强制模式，代表SELinux正在运行中，且已经正确开始限制domain/type了
	permissive：宽容模式，代表SELinux正在运行中，不过仅会有警告信息并不会实际限制domain/type的访问。这种模式可以用来作为SELinux的调试之用
	disable：关闭
查询SELinux当前的模式：
```
getenforce
```

查询SELinux的策略（Policy）：
```
sestatus [-vb]
```
参数：
-v：检查位于/etc/sestatus.conf内的文件与程序的安全上下文内容
-b：将目前策略的规则布尔值列出，即某些规则（rule）是否要启动之意

SELinux的配置文件是/etc/selinux/config这个文件，该文件配置了SELinux默认的策略与启动模式

将SELinux模式在enforcing与permissive之间切换：
```
setenforce [0|1]
```
参数：
0：转成permissive，宽容模式
1：转成enforcing，强制模式

修改安全上下文：
```
chcon [-R] [-t type] [-u user] [-r role] 文件
chcon [-R] --reference=范例文件 文件
```
参数：
-R：连同该目录下的子目录也同时修改
-t：后面接安全上下文的类型字段
-u：后面接身份识别
-r：后面接角色
--reference=范例文件：拿某个文件当范例来修改后续接的文件的类型

使用默认的安全上下文来还原：
```
restorecon [-Rv] 文件或目录
```
参数：
-R：连同子目录一起修改
-v：将过程显示到屏幕上

### SELinux所需的服务
settroubleshoot：将错误信息写入/var/log/messages
auditd：将详细数据写入/var/log/audit/audit.log

SELinux有提供一个audit2why的命令来查询SELinux错误信息。使用方法如下：
audit2why < /var/log/audit/audit.log

### SELinux的策略与规则管理
策略查阅
使用seinfo查询策略提供的规则
```
seinfo [-Atrub]
```
参数：
-A：列出SELinux的状态、规则布尔值、身份识别、角色、类型等所有信息
-t：列出SELinux的所有类型（type）种类
-r：列出SELinux的所有角色（role）种类
-u：列出SELinux的所有身份标识（user）种类
-b：列出所有规则的种类（布尔值）

查询详细的规则
```
sesearch [-a] [-s 主体类型] [-t 目标类型] [-b 布尔值]
```
参数：
-a：列出该类型或布尔值的所有相关信息
-t：后面还要接类型
-b：后面还要接布尔值的规则

布尔值的查询与修改
```
getsebool [-a] [布尔值条款]
```
参数：
-a：列出目前系统上面的所有布尔值条款设置为开启或关闭值

```
setsebool [-P] 布尔值=[0|1]
```
参数：
-P：直接将设置值写入配置文件，该设置数据将来会生效的

默认目录的安全上下文查询与修改
```
semanage {login|user|port|interface|fcontext|translation} -l
semanage fcontext -{a|d|m} [-frst] file_spec
```
参数：
fcontext：主要用在安全上下文方面的用途，-l为查询的意思
-a：增加的意思，你可以增加一些目录的默认安全上下文类型设置
-m：修改的意思
-d：删除的意思


